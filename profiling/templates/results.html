<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Profiling results for {{ file | default('Code Example') }}</title>
<style>
/* ============================================================================
   TYPOGRAPHY & BASE STYLES
   ============================================================================ */

h2 {
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;
    font-weight: 600;
    color: #2c3e50;
    letter-spacing: -0.5px;
}

pre {
    background: #f4f4f4;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 12px;
    overflow-x: auto;
    font-family: 'Courier New', monospace;
    font-size: 14px;
    line-height: 1.5;
    position: relative;
}

code {
    display: block;
    position: relative;
}

/* ============================================================================
   BUTTONS
   ============================================================================ */

#close-all-dialogs {
    transition: background-color 0.2s ease;
}

#close-all-dialogs:hover {
    background: #5ca77a !important;
}

.dialog-close {
    background: none;
    border: none;
    font-size: 18px;
    color: #666;
    cursor: pointer;
    padding: 2px 6px;
    border-radius: 4px;
    transition: all 0.2s;
    line-height: 1;
}

.dialog-close:hover {
    background: #f0f0f0;
    color: #333;
}

/* ============================================================================
   CODE HIGHLIGHTING & INTERACTION
   ============================================================================ */

.hoverable-code {
    cursor: pointer;
    border-radius: 3px;
    padding: 2px 3px;
    margin: 0 -3px;
    transition: all 0.15s ease;
    position: relative;
    text-decoration: underline;
    text-decoration-thickness: 2px;
}

.hoverable-code:hover {
    background-color: var(--hover-bg-color, rgba(168, 213, 186, 0.4));
    padding: 3px 5px;
    margin: 0 -5px;
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    text-decoration-thickness: 3px;
}

/* ============================================================================
   DIALOG WINDOWS
   ============================================================================ */

.source-dialog {
    position: absolute;
    background: white;
    border: 2px solid #7cb798;
    border-radius: 8px;
    padding: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    z-index: 1000;
    min-width: 300px;
    min-height: 150px;
    max-width: 90vw;
    max-height: 90vh;
    overflow: hidden;
    font-family: 'Courier New', monospace;
    font-size: 13px;
    display: none;
    animation: fadeIn 0.2s ease-in-out;
    resize: both;
    user-select: none;
}

.source-dialog * {
    user-select: text;
}

.source-dialog .dialog-header,
.source-dialog .resize-handle {
    user-select: none;
}

.source-dialog.show {
    display: block;
}

@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(-5px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Dialog Header */
.dialog-header {
    cursor: move;
    user-select: none;
    margin: -12px -12px 8px -12px;
    padding: 12px;
    background: #f0f7ff;
    border-radius: 6px 6px 0 0;
    border-bottom: 1px solid #e0e0e0;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.source-info-item {
    display: inline-block;
    margin-right: 12px;
    color: #333;
    font-weight: 500;
}

/* Dialog Content Area */
.dialog-content {
    height: calc(100% - 40px);
    overflow-y: auto;
    padding-right: 8px;
}

/* Resize Handle */
.resize-handle {
    position: absolute;
    bottom: -5px;
    right: -5px;
    width: 30px;
    height: 30px;
    cursor: nwse-resize;
    z-index: 10;
    background: transparent;
}

.resize-handle::after {
    content: '';
    position: absolute;
    bottom: 5px;
    right: 5px;
    width: 20px;
    height: 20px;
    background: linear-gradient(135deg, transparent 30%, #7cb798 30%, #7cb798 40%, transparent 40%, transparent 55%, #7cb798 55%, #7cb798 65%, transparent 65%);
    opacity: 0.5;
    pointer-events: none;
}

.resize-handle:hover::after {
    opacity: 1;
    background: linear-gradient(135deg, transparent 30%, #5ca77a 30%, #5ca77a 40%, transparent 40%, transparent 55%, #5ca77a 55%, #5ca77a 65%, transparent 65%);
}

/* ============================================================================
   CONTEXT SECTIONS & DETAILS
   ============================================================================ */

.contexts-section {
    padding-top: 12px;
}

.contexts-container {
    padding-left: 8px;
}

.contexts-list {
    margin-left: 12px;
    padding-left: 0;
    list-style: none;
}

.contexts-list > li {
    margin-bottom: 6px;
    list-style-type: none;
}

/* Details/Summary Elements */
details {
    margin-top: 8px;
}

details summary {
    cursor: pointer;
    color: #0066cc;
    font-weight: 500;
    padding: 6px 10px;
    background: #e8f0fe;
    border-radius: 4px;
    margin-bottom: 8px;
    user-select: none;
}

details summary:hover {
    background: #d2e3fc;
}

details[open] > summary {
    background: #c8ddf6;
    margin-bottom: 12px;
}

details summary::before {
    content: '▶ ';
    display: inline-block;
    transition: transform 0.2s;
    margin-right: 4px;
}

details[open] > summary::before {
    transform: rotate(90deg);
}

/* Context Items */
.context-item {
    margin: 4px 0;
}

.context-item summary {
    background: #f0f7ff;
    padding: 6px 10px;
    border-radius: 4px;
    color: #1a73e8;
    font-weight: 600;
    display: inline-block;
    margin-bottom: 8px;
    transition: filter 0.2s ease;
}

.context-item summary:hover {
    background: #e1f0fe;
    filter: brightness(0.95);
}

.context-item[open] summary {
    background: #d2e3fc;
    margin-bottom: 12px;
}

.context-value {
    color: #333;
    white-space: pre-wrap;
    word-break: break-word;
    display: block;
    margin-left: 12px;
    padding: 8px 12px;
    background: #f9f9f9;
    border-left: 3px solid #1a73e8;
    border-radius: 0 4px 4px 0;
    font-family: 'Courier New', monospace;
    font-size: 12px;
    max-height: 200px;
    overflow-y: auto;
}

/* ============================================================================
   SCROLLBARS
   ============================================================================ */

.dialog-content::-webkit-scrollbar,
.context-value::-webkit-scrollbar {
    width: 8px;
}

.dialog-content::-webkit-scrollbar-track,
.context-value::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
}

.dialog-content::-webkit-scrollbar-thumb,
.context-value::-webkit-scrollbar-thumb {
    background: #888;
    border-radius: 4px;
}

.dialog-content::-webkit-scrollbar-thumb:hover,
.context-value::-webkit-scrollbar-thumb:hover {
    background: #555;
}
</style>
</head>
<body>

<!-- ============================================================================
     MAIN CONTENT
     ============================================================================ -->

<h2>Source code for {{ file | default('Code Example') }}</h2>
<div style="position: relative;">
    <button id="close-all-dialogs" style="position: absolute; top: -35px; right: 0; padding: 6px 12px; background: #7cb798; color: white; border: none; border-radius: 4px; cursor: pointer; font-family: 'Courier New', monospace; font-size: 13px; display: none;">Close All Dialogs</button>
    <pre id="code-container"><code id="source-code">{{ code | e }}</code></pre>
</div>

<h2>Collected Heuristics</h2>
<div id="heuristics-container" style="background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border: 2px solid #dee2e6; border-radius: 8px; padding: 16px 20px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);">
    <div id="heuristics-content"></div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    'use strict';

    // ========================================================================
    // GLOBAL STATE & CONFIGURATION
    // ========================================================================

    const codeElement = document.getElementById('source-code');
    const codeText = codeElement.textContent;
    const closeAllButton = document.getElementById('close-all-dialogs');

    // Dialog management
    let openDialogs = [];
    let dialogPositions = {}; // Store positions by span index
    let dialogIdCounter = 0;
    const minTopMargin = 10; // Keep away from browser UI

    // Parse heuristics data from Jinja2
    const heuristicsRaw = {{ heuristics | tojson }};
    let heuristicsData = null;
    let totalSamples = 0;
    let totalRuns = 0;

    if (typeof heuristicsRaw === 'object' && heuristicsRaw !== null && !Array.isArray(heuristicsRaw)) {
        heuristicsData = heuristicsRaw;
        totalSamples = heuristicsData['Total-samples'] || 0;
        totalRuns = heuristicsData['Total-runs'] || 0;
    }

    /**
     * Get the success ratio for a heuristic entry
     * @param {string} key - The context key
     * @returns {number} Success ratio (successful_samples / total_runs), or 0 if not found
     */
    function getHeuristicValue(key) {
        if (!heuristicsData || !heuristicsData[key]) return 0;
        const data = heuristicsData[key];
        // New format: [successful_samples, total_runs]
        if (Array.isArray(data) && data.length >= 2) {
            const totalRuns = data[1];
            if (totalRuns === 0) return 0;
            return data[0] / totalRuns; // Return ratio
        }
        // Legacy format
        return 0;
    }

    /**
     * Get the successful and total counts for a heuristic entry
     * @param {string} key - The context key
     * @returns {Object} Object with successCount and totalCount properties
     */
    function getHeuristicCounts(key) {
        const result = {};
        if (!heuristicsData || !heuristicsData[key]) {
            result.successCount = 0;
            result.totalCount = 0;
            return result;
        }
        const data = heuristicsData[key];
        // New format: [successful_samples, total_runs]
        if (Array.isArray(data) && data.length >= 2) {
            result.successCount = data[0];
            result.totalCount = data[1];
        } else {
            result.successCount = 0;
            result.totalCount = 0;
        }
        return result;
    }

    // Parse sources data from Jinja2
    // Each context is now [dict, label] instead of just dict
    const sources = [{% for source in sources -%}
        {
            line: {{ source.get('line', 0) }},
            column: {{ source.get('column', 0) }},
            position: {{ source.get('position', 0) }},
            span: {{ source.get('span', 0) }},
            contexts: {% if source.get('contexts') %}{ {% for key, value in source['contexts'].items() %}{% if value is sequence and value|length == 2 %}"{{ key | replace('"', '\\"') | replace('\n', '\\n') | replace('\r', '\\r') }}": { "value": "{{ value[0] | replace('"', '\\"') | replace('\n', '\\n') | replace('\r', '\\r') }}", "label": "{{ value[1] | replace('"', '\\"') | replace('\n', '\\n') | replace('\r', '\\r') }}" }{% else %}"{{ key | replace('"', '\\"') | replace('\n', '\\n') | replace('\r', '\\r') }}": { "value": "{{ value | replace('"', '\\"') | replace('\n', '\\n') | replace('\r', '\\r') }}", "label": "" }{% endif %}{% if not loop.last %}, {% endif %}{% endfor %} }{% else %}{}{% endif %}
        }{% if not loop.last %},{% endif %}
    {%- endfor %}];

    // Build a map of context keys to labels for quick lookup
    const contextLabels = {};
    sources.forEach(source => {
        if (source.contexts) {
            Object.entries(source.contexts).forEach(([key, contextData]) => {
                if (typeof contextData === 'object' && contextData.label) {
                    contextLabels[key] = contextData.label;
                }
            });
        }
    });

    // ========================================================================
    // COLOR UTILITIES
    // ========================================================================

    /**
     * Calculate color on a green-to-yellow-to-red gradient based on success ratio
     * @param {number} ratio - The success ratio (0.0 to 1.0)
     * @returns {string} RGB color string
     */
    function getColorForRatio(ratio) {
        // Clamp ratio between 0 and 1
        const normalized = Math.max(0, Math.min(ratio, 1));

        let red, green, blue;

        if (normalized < 0.4) {
            // Green to Yellow-green (0.0 - 0.4)
            // Green: rgb(100, 220, 100) -> Yellow-green: rgb(200, 230, 0)
            const t = normalized / 0.4; // Normalize to 0-1 for this segment
            red = Math.round(100 + (200 - 100) * t);
            green = Math.round(220 + (230 - 220) * t);
            blue = Math.round(100 * (1 - t));
        } else if (normalized < 0.6) {
            // Yellow-green to Orange (0.4 - 0.6)
            // Yellow-green: rgb(200, 230, 0) -> Orange: rgb(240, 160, 0)
            const t = (normalized - 0.4) / 0.2; // Normalize to 0-1 for this segment
            red = Math.round(200 + (240 - 200) * t);
            green = Math.round(230 - (230 - 160) * t);
            blue = 0;
        } else {
            // Orange to Red (0.6 - 1.0)
            // Orange: rgb(240, 160, 0) -> Red: rgb(220, 0, 0)
            const t = (normalized - 0.6) / 0.4; // Normalize to 0-1 for this segment
            red = Math.round(240 - (240 - 220) * t);
            green = Math.round(160 * (1 - t));
            blue = 0;
        }

        return `rgb(${red}, ${green}, ${blue})`;
    }

    /**
     * Create a darker version of an RGB color (70% brightness)
     * @param {string} rgbColor - RGB color string like "rgb(100, 220, 100)"
     * @returns {string} Darker RGB color string
     */
    function darkenColor(rgbColor) {
        const rgb = rgbColor.match(/\d+/g).map(Number);
        const darkerRgb = rgb.map(c => Math.max(0, Math.round(c * 0.7)));
        return `rgb(${darkerRgb[0]}, ${darkerRgb[1]}, ${darkerRgb[2]})`;
    }

    // ========================================================================
    // HTML UTILITIES
    // ========================================================================

    /**
     * Escape HTML special characters
     * @param {string} text - Text to escape
     * @returns {string} Escaped HTML
     */
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Pretty print context values (attempts JSON formatting)
     * @param {string} value - Value to format
     * @returns {string} Formatted and escaped HTML
     */
    function prettyPrintContext(value) {
        try {
            const parsed = JSON.parse(value);
            return escapeHtml(JSON.stringify(parsed, null, 2));
        } catch (e) {
            // Not JSON - check if it looks like structured data
            let formatted = value;

            if (/[\{\}\[\]\(\),]/.test(value) && value.trim().length > 0) {
                formatted = value
                    .replace(/,\s*/g, ',\n  ')
                    .replace(/\{/g, '{\n  ')
                    .replace(/\}/g, '\n}')
                    .replace(/\[/g, '[\n  ')
                    .replace(/\]/g, '\n]')
                    .replace(/\(\s*/g, '(\n  ')
                    .replace(/\s*\)/g, '\n)');

                formatted = formatted.replace(/\n{3,}/g, '\n\n');
            }

            return escapeHtml(formatted);
        }
    }

    // ========================================================================
    // HEURISTICS DISPLAY
    // ========================================================================

    /**
     * Populate the heuristics display section with tiles grouped by flip count
     */
    function populateHeuristicsDisplay() {
        const heuristicsContent = document.getElementById('heuristics-content');

        if (!heuristicsData || typeof heuristicsData === 'string') {
            heuristicsContent.innerHTML = '<div style="color: #6c757d; font-style: italic;">No heuristics data available</div>';
            return;
        }

        let html = '';

        // Group keys by their flip count
        const keys = Object.keys(heuristicsData).filter(k => k !== 'Total-runs' && k !== 'Total-samples');

        // Display totals prominently in horizontal layout
        if (totalSamples > 0 || totalRuns > 0) {
            html += `<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 16px;">`;

            if (totalSamples > 0) {
                html += `
                    <div style="background: white; border-left: 4px solid #2c3e50; padding: 12px 16px; border-radius: 4px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);">
                        <span style="font-weight: 700; color: #2c3e50; font-size: 14px;">Samples:</span>
                        <span style="font-size: 18px; font-weight: 600; color: #495057; margin-left: 8px; font-family: 'Monaco', monospace;">${totalSamples}</span>
                    </div>
                `;
            }

            if (totalRuns > 0) {
                html += `
                    <div style="background: white; border-left: 4px solid #2c3e50; padding: 12px 16px; border-radius: 4px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);">
                        <span style="font-weight: 700; color: #2c3e50; font-size: 14px;">Runs:</span>
                        <span style="font-size: 18px; font-weight: 600; color: #495057; margin-left: 8px; font-family: 'Monaco', monospace;">${totalRuns}</span>
                    </div>
                `;
            }

            html += `</div>`;
        }

        if (keys.length > 0) {
            html += `
                <div style="background: white; border-left: 4px solid #2c3e50; padding: 12px 16px; margin-bottom: 16px; border-radius: 4px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);">
                    <span style="font-weight: 700; color: #2c3e50; font-size: 14px;">Flips:</span>
                    <span style="font-size: 18px; font-weight: 600; color: #495057; margin-left: 8px; font-family: 'Monaco', monospace;">${keys.length}</span>
                </div>
            `;
        }

        if (keys.length > 0) {
            // Sort keys by their ratio (descending)
            const sortedKeys = keys.map(key => ({
                key,
                ratio: getHeuristicValue(key)
            })).sort((a, b) => b.ratio - a.ratio);

            // Create responsive grid container for flip tiles
            html += `<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 8px; margin-bottom: 16px;">`;

            // Create individual flip tiles
            sortedKeys.forEach(({ key, ratio }) => {
                const color = getColorForRatio(ratio);
                const percentage = (ratio * 100).toFixed(1);
                const rgb = color.match(/\d+/g).map(Number);
                const bgColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.2)`;
                const hoverBgColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.35)`;

                // Get success/total counts for this flip
                const counts = getHeuristicCounts(key);

                // Get label for this context key
                const contextLabel = contextLabels[key];

                // Build compact multi-line display
                const titleText = `${key}${contextLabel ? ' [' + contextLabel + ']' : ''} - ${counts.successCount}/${counts.totalCount} successful - Click to focus`;

                html += `
                    <div class="heuristic-tile" data-context-key="${escapeHtml(key)}"
                         style="background: ${bgColor}; color: #212529; padding: 6px 8px;
                                border-radius: 6px; cursor: pointer;
                                transition: all 0.15s ease; border-left: 4px solid ${color};
                                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
                                display: flex; flex-direction: column; gap: 4px; min-height: 0;"
                         onmouseover="this.style.background='${hoverBgColor}'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 3px 8px rgba(0,0,0,0.15)';"
                         onmouseout="this.style.background='${bgColor}'; this.style.transform=''; this.style.boxShadow='0 1px 3px rgba(0, 0, 0, 0.08)';"
                         title="${escapeHtml(titleText)}">
                        ${contextLabel ? `<div style="font-size: 10px; font-weight: 700; color: #212529; word-wrap: break-word; overflow-wrap: break-word; line-height: 1.3;">${escapeHtml(contextLabel)}</div>` : ''}
                        <div style="font-size: 8px; font-weight: 400; color: #868e96; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${escapeHtml(key)}</div>
                        <div style="display: flex; justify-content: space-between; align-items: center; gap: 8px; margin-top: 2px;">
                            <div style="font-size: 14px; font-weight: 700; color: #212529; font-family: 'Monaco', monospace;">${percentage}%</div>
                            <div style="font-size: 8px; color: #6c757d; white-space: nowrap;">${counts.successCount}/${counts.totalCount}</div>
                        </div>
                    </div>
                `;
            });

            html += '</div>';
        }

        // Add section for code span summaries
        html += '<hr style="border: none; border-top: 2px solid #dee2e6; margin: 24px 0;">';
        html += '<h3 style="font-family: Monaco, monospace; color: #2c3e50; font-size: 16px; font-weight: 700; margin-bottom: 16px;">Code Locations</h3>';

        // Calculate average color for each source
        const sourcesSummary = sources
            .map((source, index) => {
                if (!source.contexts || Object.keys(source.contexts).length === 0) {
                    return null;
                }

                let totalRatio = 0;
                let count = 0;
                const contextKeys = Object.keys(source.contexts);

                // Only count contexts that exist in heuristicsData
                contextKeys.forEach(contextKey => {
                    if (heuristicsData && heuristicsData[contextKey] !== undefined) {
                        const ratio = getHeuristicValue(contextKey);
                        totalRatio += ratio;
                        count++;
                    }
                });

                if (count === 0) return null;

                const averageRatio = totalRatio / count;
                const avgColor = getColorForRatio(averageRatio);
                const percentage = (averageRatio * 100).toFixed(1);

                return {
                    index,
                    source,
                    averageRatio,
                    avgColor,
                    percentage,
                    contextCount: count
                };
            })
            .filter(item => item !== null)
            .sort((a, b) => b.averageRatio - a.averageRatio);

        if (sourcesSummary.length > 0) {
            sourcesSummary.forEach(item => {
                const rgb = item.avgColor.match(/\d+/g).map(Number);
                const bgColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.15)`;

                html += `
                    <div class="code-location-card" data-source-index="${item.index}"
                         style="background: white; border-radius: 6px; padding: 10px 12px; border-left: 4px solid ${item.avgColor};
                                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08); transition: all 0.15s ease; cursor: pointer; margin-bottom: 8px;"
                         onmouseover="this.style.boxShadow='0 3px 8px rgba(0, 0, 0, 0.12)';"
                         onmouseout="this.style.boxShadow='0 1px 3px rgba(0, 0, 0, 0.08)';">
                        <div style="font-size: 11px; color: #6c757d; margin-bottom: 6px; font-weight: 500;">
                            Line ${item.source.line}:${item.source.column} • Span ${item.source.span}
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 6px;">
                            <span style="font-size: 16px; font-weight: 600; color: #212529; font-family: 'Monaco', monospace;">${item.percentage}%</span>
                            <span style="font-size: 11px; color: #868e96; font-weight: 500;">avg success</span>
                        </div>
                        <div style="font-size: 10px; color: #868e96; background: ${bgColor}; padding: 3px 6px; border-radius: 3px; text-align: center;">
                            ${item.contextCount} context${item.contextCount !== 1 ? 's' : ''}
                        </div>
                    </div>
                `;
            });
        }

        heuristicsContent.innerHTML = html;
    }

    /**
     * Add click handlers to heuristic tiles and code location cards
     */
    function initializeHeuristicTileHandlers() {
        setTimeout(() => {
            // Handle flip badge clicks
            const tiles = document.querySelectorAll('.heuristic-tile');
            tiles.forEach(tile => {
                tile.addEventListener('click', function() {
                    const contextKey = this.dataset.contextKey;
                    focusOnContext(contextKey);
                });
            });

            // Handle code location card clicks
            const locationCards = document.querySelectorAll('.code-location-card');
            locationCards.forEach(card => {
                card.addEventListener('click', function() {
                    const sourceIndex = parseInt(this.dataset.sourceIndex);
                    focusOnCodeLocation(sourceIndex);
                });
            });
        }, 100);
    }

    /**
     * Focus on a code location by opening/focusing its dialog
     * @param {number} sourceIndex - Index of the source to focus on
     */
    function focusOnCodeLocation(sourceIndex) {
        const source = sources[sourceIndex];
        if (!source) return;

        // Find the corresponding span
        const span = codeElement.querySelector(`.hoverable-code[data-index="${sourceIndex}"]`);
        if (!span) return;

        // Check if dialog already exists for this span
        const existingDialog = openDialogs.find(d => d.spanIndex === sourceIndex);

        if (existingDialog) {
            // Dialog exists, just focus it
            const dialog = document.getElementById(existingDialog.id);
            if (dialog) {
                dialog.style.zIndex = 1000 + (++dialogIdCounter);
                repositionDialogIfOffScreen(dialog);
                scrollPageToDialog(dialog);
            }
        } else {
            // Open new dialog
            showDialog(span, source, sourceIndex);

            // Scroll to show the dialog
            setTimeout(() => {
                const newDialog = openDialogs[openDialogs.length - 1];
                if (newDialog) {
                    const dialog = document.getElementById(newDialog.id);
                    if (dialog) {
                        scrollPageToDialog(dialog);
                    }
                }
            }, 50);
        }

        // Also scroll the code into view
        span.scrollIntoView({
            behavior: 'smooth',
            block: 'center',
            inline: 'nearest'
        });
    }

    // ========================================================================
    // CONTEXT FOCUSING & NAVIGATION
    // ========================================================================

    /**
     * Find and focus on a context - either in open dialogs or by opening new dialog
     * @param {string} contextKey - The context key to find and focus
     * @returns {boolean} True if context was found and focused
     */
    function focusOnContext(contextKey) {
        // First, search through all open dialogs
        if (focusContextInOpenDialogs(contextKey)) {
            return true;
        }

        // If not found, find and open the dialog containing this context
        return openDialogForContext(contextKey);
    }

    /**
     * Focus on a context within already-open dialogs
     * @param {string} contextKey - The context key to find
     * @returns {boolean} True if found and focused
     */
    function focusContextInOpenDialogs(contextKey) {
        for (const dialogInfo of openDialogs) {
            const dialog = document.getElementById(dialogInfo.id);
            if (!dialog) continue;

            const contextItems = dialog.querySelectorAll('.context-item');
            for (const item of contextItems) {
                const li = item.closest('li');
                // Match by data-context-key attribute instead of text content
                if (li && li.dataset.contextKey === contextKey) {
                    // Bring dialog to front
                    dialog.style.zIndex = 1000 + (++dialogIdCounter);

                    // Reposition if off-screen
                    repositionDialogIfOffScreen(dialog);

                    // Open the context dropdown
                    item.open = true;

                    // Scroll within dialog
                    scrollToContextInDialog(dialog, item);

                    // Scroll page to show dialog
                    scrollPageToDialog(dialog);

                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Open a new dialog containing the specified context
     * @param {string} contextKey - The context key to find
     * @returns {boolean} True if dialog was opened
     */
    function openDialogForContext(contextKey) {
        for (let i = 0; i < sources.length; i++) {
            const source = sources[i];
            if (source.contexts && source.contexts[contextKey] !== undefined) {
                const span = codeElement.querySelector(`.hoverable-code[data-index="${i}"]`);
                if (span) {
                    showDialog(span, source, i);

                    // Wait for dialog creation, then focus context
                    setTimeout(() => {
                        const newDialog = openDialogs[openDialogs.length - 1];
                        if (newDialog) {
                            const dialog = document.getElementById(newDialog.id);
                            if (dialog) {
                                focusContextInNewDialog(dialog, contextKey);
                                scrollPageToDialog(dialog);
                            }
                        }
                    }, 50);

                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Focus on a specific context within a newly-opened dialog
     * @param {HTMLElement} dialog - The dialog element
     * @param {string} contextKey - The context key to focus
     */
    function focusContextInNewDialog(dialog, contextKey) {
        const contextItems = dialog.querySelectorAll('.context-item');
        for (const item of contextItems) {
            const li = item.closest('li');
            // Match by data-context-key attribute instead of text content
            if (li && li.dataset.contextKey === contextKey) {
                item.open = true;
                scrollToContextInDialog(dialog, item);
                break;
            }
        }
    }

    /**
     * Reposition dialog to center if it's off-screen
     * @param {HTMLElement} dialog - The dialog element
     */
    function repositionDialogIfOffScreen(dialog) {
        const dialogRect = dialog.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        const isOffScreen = (
            dialogRect.right < 50 ||
            dialogRect.left > viewportWidth - 50 ||
            dialogRect.bottom < 50 ||
            dialogRect.top > viewportHeight - 50
        );

        if (isOffScreen) {
            const centerX = (viewportWidth - dialog.offsetWidth) / 2;
            const centerY = (viewportHeight - dialog.offsetHeight) / 2;

            dialog.style.left = Math.max(20, centerX) + 'px';
            dialog.style.top = Math.max(20, centerY) + 'px';
        }
    }

    /**
     * Scroll to a context item within a dialog
     * @param {HTMLElement} dialog - The dialog element
     * @param {HTMLElement} item - The context item element
     */
    function scrollToContextInDialog(dialog, item) {
        const dialogContent = dialog.querySelector('.dialog-content');
        if (dialogContent) {
            const itemTop = item.offsetTop;
            dialogContent.scrollTop = itemTop - 50;
        }
    }

    /**
     * Scroll the page to bring dialog into view
     * @param {HTMLElement} dialog - The dialog element
     */
    function scrollPageToDialog(dialog) {
        requestAnimationFrame(() => {
            dialog.scrollIntoView({
                behavior: 'smooth',
                block: 'center',
                inline: 'center'
            });
        });
    }

    // ========================================================================
    // DIALOG MANAGEMENT
    // ========================================================================

    /**
     * Update the "Close All" button visibility and text
     */
    function updateCloseAllButton() {
        if (openDialogs.length > 0) {
            closeAllButton.style.display = 'block';
            closeAllButton.textContent = `Close All (${openDialogs.length} window(s) open)`;
        } else {
            closeAllButton.style.display = 'none';
        }
    }

    /**
     * Close dialog(s)
     * @param {string} dialogId - Dialog ID to close, or undefined to close all
     */
    function closeDialog(dialogId) {
        if (!dialogId || dialogId === '' || dialogId === 'all' || dialogId === undefined) {
            closeAllDialogs();
        } else {
            closeSingleDialog(dialogId);
        }
        updateCloseAllButton();
    }

    /**
     * Close all open dialogs
     */
    function closeAllDialogs() {
        openDialogs.forEach(dialogInfo => {
            const dialogEl = document.getElementById(dialogInfo.id);
            if (dialogEl) {
                rememberDialogPosition(dialogInfo, dialogEl);
                cleanupDialogEventHandlers(dialogEl);
                dialogEl.remove();
            }
            removeSpanHighlight(dialogInfo.spanElement);
        });
        openDialogs = [];
    }

    /**
     * Close a single dialog
     * @param {string} dialogId - Dialog ID to close
     */
    function closeSingleDialog(dialogId) {
        const dialogInfo = openDialogs.find(d => d.id === dialogId);
        if (dialogInfo) {
            const dialog = document.getElementById(dialogId);
            if (dialog) {
                rememberDialogPosition(dialogInfo, dialog);
                cleanupDialogEventHandlers(dialog);
                dialog.remove();
            }
            removeSpanHighlight(dialogInfo.spanElement);
            openDialogs = openDialogs.filter(d => d.id !== dialogId);
        }
    }

    /**
     * Remember dialog position for reopening
     * @param {Object} dialogInfo - Dialog info object
     * @param {HTMLElement} dialog - Dialog element
     */
    function rememberDialogPosition(dialogInfo, dialog) {
        if (dialogInfo.spanIndex !== undefined) {
            dialogPositions[dialogInfo.spanIndex] = {
                top: parseInt(dialog.style.top),
                left: parseInt(dialog.style.left),
                width: dialog.offsetWidth,
                height: dialog.offsetHeight
            };
        }
    }

    /**
     * Clean up event handlers for a dialog
     * @param {HTMLElement} dialog - Dialog element
     */
    function cleanupDialogEventHandlers(dialog) {
        if (dialog._mouseMoveHandler) {
            document.removeEventListener('mousemove', dialog._mouseMoveHandler);
        }
        if (dialog._mouseUpHandler) {
            document.removeEventListener('mouseup', dialog._mouseUpHandler);
        }
    }

    /**
     * Remove highlight from code span
     * @param {HTMLElement} span - Span element
     */
    function removeSpanHighlight(span) {
        if (span) {
            span.style.backgroundColor = '';
            span.style.border = '';
            span.style.padding = '';
            span.style.margin = '';
        }
    }

    // Make closeDialog available globally
    window.closeDialog = closeDialog;

    // ========================================================================
    // DIALOG CREATION & DISPLAY
    // ========================================================================

    /**
     * Create HTML for dialog content
     * @param {Object} source - Source data
     * @param {number} index - Source index
     * @param {string} dialogId - Dialog ID
     * @returns {string} HTML string
     */
    function createDialogHTML(source, index, dialogId) {
        let html = `
            <div class="dialog-header">
                <div>
                    <span class="source-info-item">line: ${source.line}</span>
                    <span class="source-info-item">col: ${source.column}</span>
                    <span class="source-info-item">pos: ${source.position}</span>
                    <span class="source-info-item">span: ${source.span}</span>
                </div>
                <button class="dialog-close" onclick="closeDialog()">×</button>
            </div>
            <div class="dialog-content">
        `;

        if (source.contexts && Object.keys(source.contexts).length > 0) {
            html += createContextsSection(source, dialogId);
        } else {
            html += '<p style="color: #666; margin: 20px;">No contexts available</p>';
        }

        html += '</div>';
        return html;
    }

    /**
     * Create HTML for contexts section
     * @param {Object} source - Source data
     * @param {string} dialogId - Dialog ID
     * @returns {string} HTML string
     */
    function createContextsSection(source, dialogId) {
        let html = `
            <div class="contexts-section">
                <details open>
                    <summary>Contexts (${Object.keys(source.contexts).length} items)</summary>
                    <div style="margin: 8px 0 12px 12px;">
                        <button class="sort-button" data-dialog-id="${dialogId}" data-sort="asc"
                                style="padding: 4px 8px; margin-right: 6px; border: 1px solid #ddd; border-radius: 3px; background: #f8f8f8; cursor: pointer; font-size: 12px;">
                            Sort: Low → High
                        </button>
                        <button class="sort-button" data-dialog-id="${dialogId}" data-sort="desc"
                                style="padding: 4px 8px; margin-right: 6px; border: 1px solid #ddd; border-radius: 3px; background: #f8f8f8; cursor: pointer; font-size: 12px;">
                            Sort: High → Low
                        </button>
                        <button class="sort-button" data-dialog-id="${dialogId}" data-sort="original"
                                style="padding: 4px 8px; border: 1px solid #ddd; border-radius: 3px; background: #f8f8f8; cursor: pointer; font-size: 12px;">
                            Original Order
                        </button>
                    </div>
                    <div class="contexts-container">
                        <ul class="contexts-list" data-dialog-id="${dialogId}">
        `;

        for (const [key, contextData] of Object.entries(source.contexts)) {
            const value = typeof contextData === 'object' && contextData.value !== undefined ? contextData.value : contextData;
            const label = typeof contextData === 'object' && contextData.label !== undefined ? contextData.label : '';

            // Create display label: show both key and label if label exists
            const displayLabel = label ? `${escapeHtml(key)} [${escapeHtml(label)}]` : escapeHtml(key);

            html += `
                <li data-context-key="${escapeHtml(key)}">
                    <details class="context-item">
                        <summary>${displayLabel}</summary>
                        <div class="context-value">${prettyPrintContext(value)}</div>
                    </details>
                </li>
            `;
        }

        html += `
                        </ul>
                    </div>
                </details>
            </div>
        `;

        return html;
    }

    /**
     * Calculate average heuristic color for a source's contexts
     * @param {Object} source - Source data
     * @returns {Object} Object with spanColor and spanBorderColor
     */
    function calculateSourceColors(source) {
        let spanColor = '#a8d5ba'; // Default light green
        let spanBorderColor = '#7cb798';

        if (heuristicsData && totalRuns > 0 && source.contexts && Object.keys(source.contexts).length > 0) {
            let totalRatio = 0;
            let count = 0;

            for (const contextKey of Object.keys(source.contexts)) {
                const ratio = getHeuristicValue(contextKey);
                totalRatio += ratio;
                count++;
            }

            if (count > 0) {
                const averageRatio = totalRatio / count;
                spanColor = getColorForRatio(averageRatio);
                spanBorderColor = darkenColor(spanColor);
            }
        }

        return { spanColor, spanBorderColor };
    }

    /**
     * Show dialog for a code span
     * @param {HTMLElement} span - Span element
     * @param {Object} source - Source data
     * @param {number} index - Source index
     */
    function showDialog(span, source, index) {
        const { spanColor, spanBorderColor } = calculateSourceColors(source);

        // Highlight the span
        span.style.backgroundColor = spanColor;
        span.style.border = `1px solid ${spanBorderColor}`;

        // Create dialog
        const dialogId = 'dialog-' + (++dialogIdCounter);
        const dialog = document.createElement('div');
        dialog.className = 'source-dialog show';
        dialog.id = dialogId;
        dialog.innerHTML = createDialogHTML(source, index, dialogId);
        dialog.style.borderColor = spanBorderColor;

        // Add resize handle
        const resizeHandle = document.createElement('div');
        resizeHandle.className = 'resize-handle';
        dialog.appendChild(resizeHandle);

        // Setup close button
        setupDialogCloseButton(dialog, dialogId);

        // Position and display dialog
        document.body.appendChild(dialog);
        positionDialog(dialog, span, index);

        // Store dialog info
        openDialogs.push({
            id: dialogId,
            element: dialog,
            position: { top: parseInt(dialog.style.top), left: parseInt(dialog.style.left) },
            spanElement: span,
            spanIndex: index
        });

        // Setup dialog interactions
        setupDialogDragging(dialog, dialogId);
        setupDialogResizing(dialog, resizeHandle, dialogId);
        setupDialogFocusing(dialog);

        // Apply heuristic colors to context items
        applyHeuristicColorsToContexts(dialog);

        // Setup sort buttons
        setupSortButtons(dialog);

        updateCloseAllButton();
    }

    /**
     * Setup close button for dialog
     * @param {HTMLElement} dialog - Dialog element
     * @param {string} dialogId - Dialog ID
     */
    function setupDialogCloseButton(dialog, dialogId) {
        const closeButton = dialog.querySelector('.dialog-close');
        if (closeButton) {
            closeButton.onclick = null;
            closeButton.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                closeDialog(dialogId);
            }, false);
        }
    }

    /**
     * Position dialog based on span location and remembered position
     * @param {HTMLElement} dialog - Dialog element
     * @param {HTMLElement} span - Span element
     * @param {number} index - Source index
     */
    function positionDialog(dialog, span, index) {
        let top, left, width = 500, height = 400;

        if (dialogPositions[index]) {
            const remembered = dialogPositions[index];
            top = remembered.top;
            left = remembered.left;
            width = remembered.width || 500;
            height = remembered.height || 400;

            // Ensure position is within bounds
            top = Math.max(minTopMargin, Math.min(top, window.innerHeight - 50));
            left = Math.max(0, Math.min(left, window.innerWidth - 100));
        } else {
            const spanRect = span.getBoundingClientRect();
            const offset = openDialogs.length * 20;

            top = spanRect.bottom + window.scrollY + 10 + offset;
            left = spanRect.left + window.scrollX + offset;

            // Check if dialog would go off bottom
            if (top + height > window.innerHeight + window.scrollY) {
                top = spanRect.top + window.scrollY - height - 10;
            }

            top = Math.max(minTopMargin, top - window.scrollY) + window.scrollY;

            // Check if dialog would go off right edge
            if (left + width > window.innerWidth + window.scrollX) {
                left = window.innerWidth + window.scrollX - width - 20;
            }
        }

        dialog.style.top = top + 'px';
        dialog.style.left = left + 'px';
        dialog.style.width = width + 'px';
        dialog.style.height = height + 'px';
        dialog.style.zIndex = 1000 + dialogIdCounter;
    }

    /**
     * Setup dragging functionality for dialog
     * @param {HTMLElement} dialog - Dialog element
     * @param {string} dialogId - Dialog ID
     */
    function setupDialogDragging(dialog, dialogId) {
        const header = dialog.querySelector('.dialog-header');
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };

        header.addEventListener('mousedown', function(e) {
            if (e.target.classList.contains('dialog-close')) return;

            isDragging = true;
            dragOffset.x = e.clientX - dialog.offsetLeft;
            dragOffset.y = e.clientY - dialog.offsetTop;
            dialog.style.cursor = 'grabbing';
            dialog.style.zIndex = 1000 + (++dialogIdCounter);
        });

        const mouseMoveHandler = function(e) {
            if (!document.getElementById(dialogId)) {
                document.removeEventListener('mousemove', mouseMoveHandler);
                document.removeEventListener('mouseup', mouseUpHandler);
                return;
            }

            if (isDragging) {
                let newX = e.clientX - dragOffset.x;
                let newY = e.clientY - dragOffset.y;

                const minVisibleHeight = 50;
                const minSideMargin = 100;

                newX = Math.max(-dialog.offsetWidth + minSideMargin,
                               Math.min(newX, window.innerWidth - minSideMargin));
                newY = Math.max(minTopMargin,
                               Math.min(newY, window.innerHeight - minVisibleHeight));

                dialog.style.left = newX + 'px';
                dialog.style.top = newY + 'px';

                updateDialogPosition(dialogId, newX, newY, dialog.offsetWidth, dialog.offsetHeight);
            }
        };

        const mouseUpHandler = function() {
            isDragging = false;
            dialog.style.cursor = '';
        };

        document.addEventListener('mousemove', mouseMoveHandler);
        document.addEventListener('mouseup', mouseUpHandler);

        dialog._mouseMoveHandler = mouseMoveHandler;
        dialog._mouseUpHandler = mouseUpHandler;
    }

    /**
     * Setup resizing functionality for dialog
     * @param {HTMLElement} dialog - Dialog element
     * @param {HTMLElement} resizeHandle - Resize handle element
     * @param {string} dialogId - Dialog ID
     */
    function setupDialogResizing(dialog, resizeHandle, dialogId) {
        let isResizing = false;
        let resizeStart = { x: 0, y: 0, width: 0, height: 0 };

        resizeHandle.addEventListener('mousedown', function(e) {
            e.preventDefault();
            e.stopPropagation();
            isResizing = true;
            resizeStart.x = e.clientX;
            resizeStart.y = e.clientY;
            resizeStart.width = dialog.offsetWidth;
            resizeStart.height = dialog.offsetHeight;
            dialog.style.resize = 'none';
            dialog.style.zIndex = 1000 + (++dialogIdCounter);
        });

        const existingMoveHandler = dialog._mouseMoveHandler;
        const resizeMoveHandler = function(e) {
            existingMoveHandler(e);

            if (isResizing) {
                const newWidth = Math.max(300, resizeStart.width + (e.clientX - resizeStart.x));
                const newHeight = Math.max(150, resizeStart.height + (e.clientY - resizeStart.y));

                dialog.style.width = newWidth + 'px';
                dialog.style.height = newHeight + 'px';

                updateDialogPosition(dialogId, parseInt(dialog.style.left), parseInt(dialog.style.top), newWidth, newHeight);
            }
        };

        const existingUpHandler = dialog._mouseUpHandler;
        const resizeUpHandler = function() {
            existingUpHandler();
            isResizing = false;
            dialog.style.resize = 'both';
        };

        // Replace handlers with combined versions
        document.removeEventListener('mousemove', existingMoveHandler);
        document.removeEventListener('mouseup', existingUpHandler);
        document.addEventListener('mousemove', resizeMoveHandler);
        document.addEventListener('mouseup', resizeUpHandler);

        dialog._mouseMoveHandler = resizeMoveHandler;
        dialog._mouseUpHandler = resizeUpHandler;
    }

    /**
     * Setup dialog focusing on click
     * @param {HTMLElement} dialog - Dialog element
     */
    function setupDialogFocusing(dialog) {
        dialog.addEventListener('mousedown', function() {
            dialog.style.zIndex = 1000 + (++dialogIdCounter);
        });
    }

    /**
     * Update stored dialog position
     * @param {string} dialogId - Dialog ID
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {number} width - Width
     * @param {number} height - Height
     */
    function updateDialogPosition(dialogId, x, y, width, height) {
        const dialogInfo = openDialogs.find(d => d.id === dialogId);
        if (dialogInfo) {
            dialogInfo.position = { top: y, left: x };
            if (dialogInfo.spanIndex !== undefined) {
                dialogPositions[dialogInfo.spanIndex] = { top: y, left: x, width, height };
            }
        }
    }

    /**
     * Apply heuristic colors to context summaries
     * @param {HTMLElement} dialog - Dialog element
     */
    function applyHeuristicColorsToContexts(dialog) {
        if (!heuristicsData || totalRuns === 0) return;

        const contextItems = dialog.querySelectorAll('.context-item');
        contextItems.forEach(item => {
            const summary = item.querySelector('summary');
            const li = item.closest('li');
            const contextKey = li.dataset.contextKey;
            const ratio = getHeuristicValue(contextKey);
            const counts = getHeuristicCounts(contextKey);
            const color = getColorForRatio(ratio);

            // Get the label from the current display text (extract from brackets if present)
            const currentText = summary.textContent.trim();
            const bracketMatch = currentText.match(/\[([^\]]+)\]$/);
            const label = bracketMatch ? bracketMatch[1] : '';

            // Update summary to show success/total counts with label
            const displayLabel = label ? `${escapeHtml(contextKey)} [${escapeHtml(label)}]` : escapeHtml(contextKey);
            summary.innerHTML = `${displayLabel} <span style="font-size: 10px; opacity: 0.9;">(${counts.successCount}/${counts.totalCount})</span>`;

            summary.style.backgroundColor = color;
            summary.style.color = 'white';
            summary.style.textShadow = '0 1px 2px rgba(0, 0, 0, 0.3)';
        });
    }

    /**
     * Setup sort button event listeners
     * @param {HTMLElement} dialog - Dialog element
     */
    function setupSortButtons(dialog) {
        const sortButtons = dialog.querySelectorAll('.sort-button');
        sortButtons.forEach(button => {
            button.addEventListener('click', function() {
                const sortType = this.dataset.sort;
                const targetDialogId = this.dataset.dialogId;
                const contextsList = dialog.querySelector(`.contexts-list[data-dialog-id="${targetDialogId}"]`);

                if (!contextsList) return;

                const items = Array.from(contextsList.querySelectorAll('li'));

                // Store original order
                if (!contextsList.dataset.originalOrder) {
                    contextsList.dataset.originalOrder = items.map(item => item.dataset.contextKey).join('|||');
                }

                if (sortType === 'original') {
                    restoreOriginalOrder(items, contextsList);
                } else {
                    sortByHeuristic(items, sortType);
                }

                // Re-append in sorted order
                items.forEach(item => contextsList.appendChild(item));

                // Update button styles
                updateSortButtonStyles(sortButtons, this);
            });
        });
    }

    /**
     * Restore original order of context items
     * @param {Array} items - Array of list items
     * @param {HTMLElement} contextsList - Contexts list element
     */
    function restoreOriginalOrder(items, contextsList) {
        const originalKeys = contextsList.dataset.originalOrder.split('|||');
        items.sort((a, b) => {
            return originalKeys.indexOf(a.dataset.contextKey) - originalKeys.indexOf(b.dataset.contextKey);
        });
    }

    /**
     * Sort items by heuristic value
     * @param {Array} items - Array of list items
     * @param {string} sortType - 'asc' or 'desc'
     */
    function sortByHeuristic(items, sortType) {
        items.sort((a, b) => {
            const keyA = a.dataset.contextKey;
            const keyB = b.dataset.contextKey;
            const valueA = getHeuristicValue(keyA);
            const valueB = getHeuristicValue(keyB);

            return sortType === 'asc' ? valueA - valueB : valueB - valueA;
        });
    }

    /**
     * Update sort button visual states
     * @param {NodeList} sortButtons - All sort buttons
     * @param {HTMLElement} activeButton - Currently active button
     */
    function updateSortButtonStyles(sortButtons, activeButton) {
        sortButtons.forEach(btn => {
            btn.style.background = '#f8f8f8';
            btn.style.fontWeight = 'normal';
        });
        activeButton.style.background = '#e0e0e0';
        activeButton.style.fontWeight = 'bold';
    }

    // ========================================================================
    // CODE SPAN WRAPPING & HIGHLIGHTING
    // ========================================================================

    /**
     * Wrap source code with hoverable spans
     */
    function wrapCodeWithSpans() {
        const sortedSources = sources.map((source, index) => ({...source, index}))
            .sort((a, b) => a.position - b.position);

        let html = '';
        let lastPos = 0;

        sortedSources.forEach(source => {
            const adjustedPosition = source.position - 1;

            if (adjustedPosition > lastPos) {
                html += escapeHtml(codeText.substring(lastPos, adjustedPosition));
            }

            const effectiveStart = Math.max(adjustedPosition, lastPos);
            const effectiveEnd = adjustedPosition + source.span;

            if (effectiveStart < effectiveEnd) {
                html += '<span class="hoverable-code" data-index="' + source.index + '">' +
                        escapeHtml(codeText.substring(effectiveStart, effectiveEnd)) +
                        '</span>';
                lastPos = effectiveEnd;
            }
        });

        if (lastPos < codeText.length) {
            html += escapeHtml(codeText.substring(lastPos));
        }

        codeElement.innerHTML = html;

        setupCodeSpanInteractions();
    }

    /**
     * Setup click listeners and color coding for code spans
     */
    function setupCodeSpanInteractions() {
        const codeSpans = codeElement.querySelectorAll('.hoverable-code');
        codeSpans.forEach(span => {
            const index = parseInt(span.dataset.index);
            const source = sources[index];

            applyUnderlineColor(span, source);
            setupCodeSpanClickHandler(span, source, index);
        });
    }

    /**
     * Apply underline color based on heuristics
     * @param {HTMLElement} span - Span element
     * @param {Object} source - Source data
     */
    function applyUnderlineColor(span, source) {
        if (!heuristicsData || totalRuns === 0 || !source.contexts) return;

        const contextKeys = Object.keys(source.contexts);
        if (contextKeys.length === 0) return;

        let totalRatio = 0;
        let count = 0;

        contextKeys.forEach(contextKey => {
            const ratio = getHeuristicValue(contextKey);
            totalRatio += ratio;
            count++;
        });

        if (count > 0) {
            const averageRatio = totalRatio / count;
            const avgColor = getColorForRatio(averageRatio);

            span.style.textDecorationColor = avgColor;
            span.dataset.avgColor = avgColor;

            const rgb = avgColor.match(/\d+/g).map(Number);
            const hoverColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.4)`;
            span.style.setProperty('--hover-bg-color', hoverColor);
        }
    }

    /**
     * Setup click handler for code span
     * @param {HTMLElement} span - Span element
     * @param {Object} source - Source data
     * @param {number} index - Source index
     */
    function setupCodeSpanClickHandler(span, source, index) {
        span.addEventListener('click', function(e) {
            e.stopPropagation();

            // Check if dialog already open for this span
            const existingDialog = openDialogs.find(d => d.spanElement === this);
            if (existingDialog) {
                const dialog = document.getElementById(existingDialog.id);
                if (dialog) {
                    dialog.style.zIndex = 1000 + (++dialogIdCounter);
                }
                return;
            }

            showDialog(this, source, index);
        });
    }

    // ========================================================================
    // INITIALIZATION
    // ========================================================================

    populateHeuristicsDisplay();
    initializeHeuristicTileHandlers();
    wrapCodeWithSpans();

    // Close all button handler
    closeAllButton.addEventListener('click', function() {
        closeDialog();
    });

    // Escape key to close all dialogs
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            closeDialog();
        }
    });
});
</script>

</body>
</html>
